"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""



def count_time(func):
    import time
    def count():
        """Сложность: O(1)"""
        start_time = time.time()                                    #O(1)
        func()
        end_time = time.time()                                      #O(1)
        print(f'Время выполнения кода - {end_time - start_time}')   #O(1)
    return count                                                    #O(1)

#   a)---------------------------------------------------------------------------
# @count_time
# def list_append():
#     """Сложность: O(n)"""
#     list_1 = []                 #O(len(list_1))
#     for i in range(0, 1000):    #O(n)
#         list_1.append(i)        #O(1)
#     return list_1               #O(1)
#
#
# @count_time
# def dict_append():
#     """Сложность: O(n)"""
#     dict_1 = {}                 #O(len(dict_1))
#     for i in range(0, 1000):    #O(n)
#         dict_1[str(i)] = i      #O(1)
#     return dict_1               #O(1)
#
#
# print(dict_append())
# print(list_append())
# Очевидно то, что список заполняется быстрее при том, что сложность и количество итераций в циклах одинаковые.
#    b)----------------------------------------------------------------------------------------------------------


# @count_time
# def list_see():
#     """Сложность: O(n)"""
#     list_2 = [i for i in range(0, 1000)]    #O(n) + O(len(list_2))
#     for i in list_2:                        #O(n)
#         print(i)                            #O(1)
#
#
# @count_time
# def dict_see():
#     """Сложность: O(n)"""
#     dict_2 = {}                             #O(len(dict_2))
#     for i in range(0, 1000):                #O(n)
#         dict_2[str(i)] = i                  #O(1)
#     for k, v in dict_2.items():             #O(n)
#         print(k, v)                         #O(1)
#
#
# dict_see()
# list_see()
# Список обрабатывается и выводит элемент почти в 2 раза быстрее чем словарь.
#   c)-----------------------------------------------------------------------------------------------------------


@count_time
def list_delete():
    """Сложность: O(n)"""
    list_3 = [i for i in range(0, 1000)]        #O(len(list_3))
    for i in list_3:                            #O(n)
        list_3.remove(i)                        #O(n)


@count_time
def dict_delete():
    """Сложность: O(n)"""
    dict_3 = {}                     #O(len(dict_3))
    for i in range(0, 1000):        #O(n)
        dict_3[str(i)] = i          #O(1)
    for k in list(dict_3):          #O(n)
        del dict_3[k]               #O(1)


list_delete()
dict_delete()
# А вот на удалении элементов по времени выигрывает словарь!


